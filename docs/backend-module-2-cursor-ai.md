# æ ¡å›­æ‹¼è½¦åŽç«¯å¼€å‘æ–‡æ¡£ - æ¨¡å— 2 (Cursor AI è´Ÿè´£)

## ðŸŽ¯ æ¨¡å—æ¦‚è¿°

**è´Ÿè´£äºº**: Cursor AI  
**æ¨¡å—èŒƒå›´**: æ‹¼è½¦ç³»ç»Ÿã€å¸‚åœºç³»ç»Ÿã€é€šçŸ¥ç³»ç»Ÿã€æ–‡ä»¶ç®¡ç†ç³»ç»Ÿ  
**å¼€å‘å‘¨æœŸ**: 2-3 å‘¨  
**ä¼˜å…ˆçº§**: é«˜

### Sprint è®¡åˆ’ä¸Žäº¤ä»˜ç›®æ ‡

- **ç¬¬ä¸€é˜¶æ®µ (Sprint 1 - ç¬¬ 1 å‘¨)**:

  - å®Œæˆé¡¹ç›®åŸºç¡€æž¶æž„æ­å»ºï¼ˆExpressã€æ•°æ®åº“è¿žæŽ¥ã€ä¸­é—´ä»¶é…ç½®ï¼‰
  - å®Œæˆç”¨æˆ·è®¤è¯/ç®¡ç†æ¨¡å—çš„å…¨éƒ¨ API
  - æä¾›ç¨³å®šçš„ã€å¯ä¾›å…¶ä»–æ¨¡å—ä¾èµ–çš„ç”¨æˆ·ç³»ç»Ÿ
  - ä¸º Claude Code æä¾› `authMiddleware` å’Œç”¨æˆ·æ•°æ®è®¿é—®æŽ¥å£

- **ç¬¬äºŒé˜¶æ®µ (Sprint 2 - ç¬¬ 2 å‘¨)**:

  - å®Œæˆæ‹¼è½¦ç³»ç»Ÿçš„å…¨éƒ¨åŠŸèƒ½å¼€å‘
  - å®žçŽ°æ™ºèƒ½åŒ¹é…ç®—æ³•å’Œè·¯çº¿ä¼˜åŒ–
  - é›†æˆåœ°å›¾æœåŠ¡ API
  - å®Œæˆæ‹¼è½¦ç›¸å…³çš„å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•

- **ç¬¬ä¸‰é˜¶æ®µ (Sprint 3 - ç¬¬ 3 å‘¨)**:
  - å®ŒæˆäºŒæ‰‹å¸‚åœºç³»ç»Ÿ
  - å®žçŽ°æ–‡ä»¶ä¸Šä¼ å’Œç®¡ç†åŠŸèƒ½
  - å®Œæˆè¯„ä»·ç³»ç»Ÿå¹¶ä¸Žæ‹¼è½¦ç³»ç»Ÿé›†æˆ
  - é›†æˆæ”¯ä»˜åŠŸèƒ½ï¼ˆå¦‚éœ€è¦ï¼‰
  - ç³»ç»Ÿé›†æˆæµ‹è¯•å’Œæ€§èƒ½ä¼˜åŒ–

### æ ¸å¿ƒèŒè´£

1. **é¡¹ç›®åŸºç¡€æž¶æž„ä¸Žæ ¸å¿ƒæœåŠ¡**: æ­å»ºæ•´ä¸ªåŽç«¯é¡¹ç›®çš„éª¨æž¶ï¼Œä¸ºæ‰€æœ‰æ¨¡å—æä¾›åŸºç¡€æ”¯æ’‘
2. **ç”¨æˆ·è®¤è¯ä¸Žç®¡ç†**: å®žçŽ°å®Œæ•´ã€å®‰å…¨çš„ç”¨æˆ·ç³»ç»Ÿï¼Œè¿™æ˜¯æ‰€æœ‰å…¶ä»–åŠŸèƒ½çš„åŸºç¡€
3. **æ‹¼è½¦ç³»ç»Ÿ**: å¼€å‘å®Œæ•´çš„è¡Œç¨‹å‘å¸ƒã€æœç´¢ã€é¢„è®¢å’Œç®¡ç†åŠŸèƒ½
4. **äºŒæ‰‹å¸‚åœº**: å¼€å‘å•†å“å‘å¸ƒã€æœç´¢ã€äº¤æ˜“åŠŸèƒ½
5. **è¯„ä»·ç³»ç»Ÿ**: å»ºç«‹é€šç”¨çš„è¯„ä»·ä½“ç³»ï¼Œå¯æ‰©å±•è‡³å„ä¸ªæ¨¡å—

### åä½œè¦ç‚¹

- **åŸºç¡€ä¼˜å…ˆ**: ç¬¬ä¸€å‘¨å¿…é¡»å®ŒæˆåŸºç¡€æž¶æž„å’Œç”¨æˆ·ç³»ç»Ÿï¼Œç¡®ä¿ä¸é˜»å¡ž Claude Code
- **æŽ¥å£æ–‡æ¡£**: æ¯å®Œæˆä¸€ä¸ª API ç«‹å³æ›´æ–°æ–‡æ¡£ï¼Œæ–¹ä¾¿å¯¹æ–¹è°ƒç”¨
- **Mock æœåŠ¡**: åˆæœŸå¯ä¸º `notificationService` å’Œ `pointsService` åˆ›å»º Mock è°ƒç”¨
- **æ•°æ®ä¸€è‡´æ€§**: ä¸Ž Claude Code åå•† `item_categories` å’Œ `activity_categories` çš„é¢„ç½®æ•°æ®
- **ä»£ç è§„èŒƒ**: ä¸¥æ ¼éµå¾ª `api-standards-specification.md` ä¸­çš„è§„èŒƒ

## ðŸ“‹ ç›®å½•

1. [æŠ€æœ¯æ ˆä¸Žæž¶æž„](#æŠ€æœ¯æ ˆä¸Žæž¶æž„)
2. [æ•°æ®åº“è®¾è®¡](#æ•°æ®åº“è®¾è®¡)
3. [æ‹¼è½¦ç³»ç»Ÿ](#æ‹¼è½¦ç³»ç»Ÿ)
4. [å¸‚åœºç³»ç»Ÿ](#å¸‚åœºç³»ç»Ÿ)
5. [é€šçŸ¥ç³»ç»Ÿ](#é€šçŸ¥ç³»ç»Ÿ)
6. [æ–‡ä»¶ç®¡ç†ç³»ç»Ÿ](#æ–‡ä»¶ç®¡ç†ç³»ç»Ÿ)
7. [API æŽ¥å£è¯¦ç»†è®¾è®¡](#apiæŽ¥å£è¯¦ç»†è®¾è®¡)
8. [å®žæ—¶é€šä¿¡](#å®žæ—¶é€šä¿¡)
9. [åœ°ç†å®šä½æœåŠ¡](#åœ°ç†å®šä½æœåŠ¡)
10. [æ”¯ä»˜é›†æˆ](#æ”¯ä»˜é›†æˆ)
11. [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
12. [æµ‹è¯•ç­–ç•¥](#æµ‹è¯•ç­–ç•¥)
13. [éƒ¨ç½²ä¸Žè¿ç»´](#éƒ¨ç½²ä¸Žè¿ç»´)
14. [å®‰å…¨è€ƒè™‘](#å®‰å…¨è€ƒè™‘)

---

## ðŸ—ï¸ æŠ€æœ¯æ ˆä¸Žæž¶æž„

### æ ¸å¿ƒæŠ€æœ¯æ ˆ

```yaml
åŽç«¯æ¡†æž¶: Node.js + Express.js / Fastify
æ•°æ®åº“:
  - ä¸»æ•°æ®åº“: PostgreSQL 15+
  - æ—¶åºæ•°æ®åº“: InfluxDB (ä½ç½®è¿½è¸ª)
  - æ–‡æ¡£æ•°æ®åº“: MongoDB (èŠå¤©è®°å½•)
å®žæ—¶é€šä¿¡: Socket.IO / WebSocket
æ¶ˆæ¯é˜Ÿåˆ—: Redis Pub/Sub + Bull Queue
åœ°å›¾æœåŠ¡: é«˜å¾·åœ°å›¾API / ç™¾åº¦åœ°å›¾API
æ–‡ä»¶å­˜å‚¨: AWS S3 / é˜¿é‡Œäº‘OSS / æœ¬åœ°å­˜å‚¨
æŽ¨é€æœåŠ¡: Firebase Cloud Messages / æžå…‰æŽ¨é€
å›¾ç‰‡å¤„ç†: Sharp / ImageMagick
æ”¯ä»˜: å¾®ä¿¡æ”¯ä»˜ / æ”¯ä»˜å®
æœç´¢å¼•æ“Ž: Elasticsearch
ç›‘æŽ§: Prometheus + Grafana
```

### é¡¹ç›®ç»“æž„

```
src/
â”œâ”€â”€ config/          # é…ç½®æ–‡ä»¶
â”‚   â”œâ”€â”€ socket.js
â”‚   â”œâ”€â”€ storage.js
â”‚   â”œâ”€â”€ payment.js
â”‚   â””â”€â”€ maps.js
â”œâ”€â”€ controllers/     # æŽ§åˆ¶å™¨
â”‚   â”œâ”€â”€ rideshare.controller.js
â”‚   â”œâ”€â”€ marketplace.controller.js
â”‚   â”œâ”€â”€ notification.controller.js
â”‚   â”œâ”€â”€ upload.controller.js
â”‚   â””â”€â”€ chat.controller.js
â”œâ”€â”€ middleware/      # ä¸­é—´ä»¶
â”‚   â”œâ”€â”€ upload.middleware.js
â”‚   â”œâ”€â”€ geolocation.middleware.js
â”‚   â”œâ”€â”€ payment.middleware.js
â”‚   â””â”€â”€ socket.middleware.js
â”œâ”€â”€ models/          # æ•°æ®æ¨¡åž‹
â”‚   â”œâ”€â”€ Ride.js
â”‚   â”œâ”€â”€ RideRequest.js
â”‚   â”œâ”€â”€ Product.js
â”‚   â”œâ”€â”€ Transaction.js
â”‚   â”œâ”€â”€ Notification.js
â”‚   â”œâ”€â”€ ChatMessage.js
â”‚   â””â”€â”€ FileUpload.js
â”œâ”€â”€ routes/          # è·¯ç”±
â”‚   â”œâ”€â”€ rideshare.routes.js
â”‚   â”œâ”€â”€ marketplace.routes.js
â”‚   â”œâ”€â”€ notification.routes.js
â”‚   â””â”€â”€ upload.routes.js
â”œâ”€â”€ services/        # ä¸šåŠ¡é€»è¾‘
â”‚   â”œâ”€â”€ rideshare.service.js
â”‚   â”œâ”€â”€ marketplace.service.js
â”‚   â”œâ”€â”€ notification.service.js
â”‚   â”œâ”€â”€ socket.service.js
â”‚   â”œâ”€â”€ maps.service.js
â”‚   â”œâ”€â”€ payment.service.js
â”‚   â””â”€â”€ storage.service.js
â”œâ”€â”€ utils/          # å·¥å…·å‡½æ•°
â”‚   â”œâ”€â”€ distance.util.js
â”‚   â”œâ”€â”€ image.util.js
â”‚   â”œâ”€â”€ notification.util.js
â”‚   â””â”€â”€ payment.util.js
â”œâ”€â”€ validators/     # è¾“å…¥éªŒè¯
â”‚   â”œâ”€â”€ rideshare.validator.js
â”‚   â”œâ”€â”€ marketplace.validator.js
â”‚   â””â”€â”€ upload.validator.js
â”œâ”€â”€ sockets/        # WebSocketå¤„ç†
â”‚   â”œâ”€â”€ ride.socket.js
â”‚   â”œâ”€â”€ chat.socket.js
â”‚   â””â”€â”€ notification.socket.js
â””â”€â”€ workers/        # åŽå°ä»»åŠ¡
    â”œâ”€â”€ notification.worker.js
    â”œâ”€â”€ matching.worker.js
    â””â”€â”€ cleanup.worker.js
```

---

## ðŸ—„ï¸ æ•°æ®åº“è®¾è®¡

### æ‹¼è½¦è¡¨ (rides)

```sql
CREATE TABLE rides (
  id SERIAL PRIMARY KEY,
  driver_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  title VARCHAR(255) NOT NULL,
  description TEXT,
  departure_location JSON NOT NULL, -- {address, latitude, longitude, poi_id}
  destination_location JSON NOT NULL,
  departure_time TIMESTAMP NOT NULL,
  estimated_arrival_time TIMESTAMP,
  seats_available INTEGER NOT NULL CHECK (seats_available > 0),
  seats_taken INTEGER DEFAULT 0,
  price_per_seat DECIMAL(10,2) NOT NULL,
  vehicle_info JSON, -- {make, model, color, license_plate}
  route_info JSON, -- {waypoints, distance, duration}
  restrictions JSON, -- {gender_preference, smoke_free, etc}
  contact_info JSON,
  status ENUM('pending', 'confirmed', 'ongoing', 'completed', 'cancelled') DEFAULT 'pending',
  payment_method ENUM('cash', 'alipay', 'wechat', 'points') DEFAULT 'cash',
  auto_accept BOOLEAN DEFAULT false,
  recurring_pattern JSON, -- for recurring rides
  weather_dependent BOOLEAN DEFAULT false,
  tags JSON,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  -- ç´¢å¼•
  INDEX idx_driver_id (driver_id),
  INDEX idx_departure_time (departure_time),
  INDEX idx_status (status),
  INDEX idx_location (((departure_location->>'latitude')::float), ((departure_location->>'longitude')::float)),
  INDEX idx_destination (((destination_location->>'latitude')::float), ((destination_location->>'longitude')::float)),
  INDEX idx_price (price_per_seat),
  FULLTEXT idx_description (title, description)
);
```

### æ‹¼è½¦è¯·æ±‚è¡¨ (ride_requests)

```sql
CREATE TABLE ride_requests (
  id SERIAL PRIMARY KEY,
  ride_id INTEGER REFERENCES rides(id) ON DELETE CASCADE,
  passenger_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  pickup_location JSON, -- optional custom pickup location
  seats_requested INTEGER NOT NULL DEFAULT 1,
  message TEXT,
  status ENUM('pending', 'accepted', 'rejected', 'cancelled', 'completed') DEFAULT 'pending',
  payment_status ENUM('unpaid', 'paid', 'refunded') DEFAULT 'unpaid',
  payment_amount DECIMAL(10,2),
  pickup_time TIMESTAMP,
  dropoff_time TIMESTAMP,
  rating INTEGER CHECK (rating >= 1 AND rating <= 5),
  review TEXT,
  emergency_contact JSON,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  UNIQUE KEY unique_user_ride (ride_id, passenger_id),
  INDEX idx_passenger_id (passenger_id),
  INDEX idx_ride_id (ride_id),
  INDEX idx_status (status),
  INDEX idx_payment_status (payment_status)
);
```

### å•†å“è¡¨ (products)

```sql
CREATE TABLE products (
  id SERIAL PRIMARY KEY,
  seller_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  title VARCHAR(255) NOT NULL,
  description TEXT NOT NULL,
  category ENUM('textbooks', 'electronics', 'furniture', 'clothing', 'sports', 'other') NOT NULL,
  condition_type ENUM('new', 'like_new', 'good', 'fair', 'poor') NOT NULL,
  price DECIMAL(10,2) NOT NULL,
  original_price DECIMAL(10,2),
  currency VARCHAR(3) DEFAULT 'CNY',
  images JSON, -- array of image URLs
  tags JSON,
  brand VARCHAR(100),
  specifications JSON,
  location JSON, -- pickup location
  availability_status ENUM('available', 'reserved', 'sold', 'hidden') DEFAULT 'available',
  delivery_options JSON, -- {pickup, delivery, shipping}
  payment_methods JSON, -- accepted payment methods
  negotiable BOOLEAN DEFAULT true,
  view_count INTEGER DEFAULT 0,
  favorite_count INTEGER DEFAULT 0,
  report_count INTEGER DEFAULT 0,
  is_featured BOOLEAN DEFAULT false,
  expires_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  -- ç´¢å¼•
  INDEX idx_seller_id (seller_id),
  INDEX idx_category (category),
  INDEX idx_price (price),
  INDEX idx_status (availability_status),
  INDEX idx_created_at (created_at DESC),
  INDEX idx_location (((location->>'latitude')::float), ((location->>'longitude')::float)),
  FULLTEXT idx_search (title, description, brand)
);
```

### äº¤æ˜“è¡¨ (transactions)

```sql
CREATE TABLE transactions (
  id SERIAL PRIMARY KEY,
  product_id INTEGER REFERENCES products(id) ON DELETE SET NULL,
  ride_id INTEGER REFERENCES rides(id) ON DELETE SET NULL,
  buyer_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  seller_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  transaction_type ENUM('product_sale', 'ride_payment', 'points_transfer') NOT NULL,
  amount DECIMAL(10,2) NOT NULL,
  currency VARCHAR(3) DEFAULT 'CNY',
  payment_method ENUM('alipay', 'wechat', 'cash', 'points', 'bank_transfer') NOT NULL,
  payment_gateway_id VARCHAR(255), -- third-party payment ID
  status ENUM('pending', 'paid', 'completed', 'refunded', 'cancelled', 'disputed') DEFAULT 'pending',
  metadata JSON,
  notes TEXT,
  escrow_until TIMESTAMP, -- for escrow payments
  dispute_reason TEXT,
  refund_amount DECIMAL(10,2),
  refund_reason TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  INDEX idx_buyer_id (buyer_id),
  INDEX idx_seller_id (seller_id),
  INDEX idx_product_id (product_id),
  INDEX idx_ride_id (ride_id),
  INDEX idx_status (status),
  INDEX idx_created_at (created_at DESC)
);
```

### é€šçŸ¥è¡¨ (notifications)

```sql
CREATE TABLE notifications (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  type ENUM('ride_request', 'ride_accepted', 'ride_cancelled', 'message', 'product_inquiry', 'transaction', 'system', 'promotion') NOT NULL,
  title VARCHAR(255) NOT NULL,
  content TEXT NOT NULL,
  data JSON, -- additional notification data
  priority ENUM('low', 'medium', 'high', 'urgent') DEFAULT 'medium',
  status ENUM('unread', 'read', 'dismissed') DEFAULT 'unread',
  delivery_method JSON, -- {push, email, sms, in_app}
  scheduled_for TIMESTAMP,
  sent_at TIMESTAMP,
  read_at TIMESTAMP,
  action_url TEXT,
  expires_at TIMESTAMP,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

  INDEX idx_user_id (user_id),
  INDEX idx_type (type),
  INDEX idx_status (status),
  INDEX idx_priority (priority),
  INDEX idx_created_at (created_at DESC),
  INDEX idx_scheduled_for (scheduled_for)
);
```

### èŠå¤©æ¶ˆæ¯è¡¨ (chat_messages)

```sql
CREATE TABLE chat_messages (
  id SERIAL PRIMARY KEY,
  conversation_id VARCHAR(255) NOT NULL, -- ride_id or product_id based conversation
  conversation_type ENUM('ride', 'product', 'support') NOT NULL,
  sender_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  recipient_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  message_type ENUM('text', 'image', 'location', 'system') DEFAULT 'text',
  content TEXT,
  media_url TEXT,
  metadata JSON,
  status ENUM('sent', 'delivered', 'read') DEFAULT 'sent',
  reply_to_id INTEGER REFERENCES chat_messages(id) ON DELETE SET NULL,
  sent_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  delivered_at TIMESTAMP,
  read_at TIMESTAMP,

  INDEX idx_conversation (conversation_id, conversation_type),
  INDEX idx_sender_id (sender_id),
  INDEX idx_recipient_id (recipient_id),
  INDEX idx_sent_at (sent_at DESC)
);
```

### æ–‡ä»¶ä¸Šä¼ è¡¨ (file_uploads)

```sql
CREATE TABLE file_uploads (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
  filename VARCHAR(255) NOT NULL,
  original_filename VARCHAR(255) NOT NULL,
  file_type VARCHAR(100) NOT NULL,
  file_size INTEGER NOT NULL,
  storage_path TEXT NOT NULL,
  public_url TEXT,
  thumbnail_url TEXT,
  purpose ENUM('avatar', 'product_image', 'chat_media', 'document', 'other') NOT NULL,
  related_id INTEGER, -- related entity ID (product_id, ride_id, etc.)
  related_type VARCHAR(50), -- related entity type
  processing_status ENUM('pending', 'processing', 'completed', 'failed') DEFAULT 'pending',
  metadata JSON,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

  INDEX idx_user_id (user_id),
  INDEX idx_purpose (purpose),
  INDEX idx_related (related_type, related_id),
  INDEX idx_created_at (created_at DESC)
);
```

---

## ðŸš— æ‹¼è½¦ç³»ç»Ÿ

### æ‹¼è½¦åŒ¹é…ç®—æ³•

```javascript
// æ™ºèƒ½æ‹¼è½¦åŒ¹é…æœåŠ¡
class RideMatchingService {
  constructor() {
    this.MATCHING_RADIUS = 5000; // 5å…¬é‡ŒèŒƒå›´å†…åŒ¹é…
    this.TIME_TOLERANCE = 3600; // 1å°æ—¶æ—¶é—´å®¹å·®
    this.MAX_DETOUR_DISTANCE = 2000; // æœ€å¤§ç»•è¡Œè·ç¦»2å…¬é‡Œ
  }

  async findMatchingRides(searchCriteria) {
    const {
      departureLocation,
      destinationLocation,
      departureTime,
      seatsNeeded = 1,
      maxPrice,
      preferences = {},
    } = searchCriteria;

    try {
      // 1. åŸºäºŽåœ°ç†ä½ç½®çš„åˆæ­¥ç­›é€‰
      const nearbyRides = await this.findRidesInRadius(
        departureLocation,
        destinationLocation,
        this.MATCHING_RADIUS
      );

      // 2. æ—¶é—´ç­›é€‰
      const timeMatchedRides = this.filterByTime(nearbyRides, departureTime);

      // 3. åº§ä½å’Œä»·æ ¼ç­›é€‰
      const availableRides = this.filterByAvailabilityAndPrice(
        timeMatchedRides,
        seatsNeeded,
        maxPrice
      );

      // 4. è·¯çº¿ä¼˜åŒ–åŒ¹é…
      const routeOptimizedRides = await this.optimizeRouteMatching(
        availableRides,
        departureLocation,
        destinationLocation
      );

      // 5. ä¸ªäººåå¥½åŒ¹é…
      const personalizedRides = this.applyPersonalPreferences(
        routeOptimizedRides,
        preferences
      );

      // 6. æ™ºèƒ½æŽ’åº
      const sortedRides = this.sortByMatchingScore(
        personalizedRides,
        searchCriteria
      );

      return sortedRides;
    } catch (error) {
      logger.error("Ride matching error:", error);
      throw new Error("Failed to find matching rides");
    }
  }

  async findRidesInRadius(departure, destination, radius) {
    const query = `
      SELECT r.*, u.first_name, u.last_name, u.avatar_url, u.rating,
             (6371 * acos(cos(radians($1)) * cos(radians((departure_location->>'latitude')::float)) 
             * cos(radians((departure_location->>'longitude')::float) - radians($2)) 
             + sin(radians($1)) * sin(radians((departure_location->>'latitude')::float)))) AS departure_distance,
             (6371 * acos(cos(radians($3)) * cos(radians((destination_location->>'latitude')::float)) 
             * cos(radians((destination_location->>'longitude')::float) - radians($4)) 
             + sin(radians($3)) * sin(radians((destination_location->>'latitude')::float)))) AS destination_distance
      FROM rides r
      JOIN users u ON r.driver_id = u.id
      WHERE r.status = 'confirmed'
        AND r.seats_available > r.seats_taken
        AND r.departure_time > NOW()
      HAVING departure_distance < $5 AND destination_distance < $5
      ORDER BY departure_distance + destination_distance ASC
    `;

    const result = await db.query(query, [
      departure.latitude,
      departure.longitude,
      destination.latitude,
      destination.longitude,
      radius / 1000, // Convert to kilometers
    ]);

    return result.rows;
  }

  filterByTime(rides, targetTime) {
    const targetTimestamp = new Date(targetTime).getTime();

    return rides.filter((ride) => {
      const rideTimestamp = new Date(ride.departure_time).getTime();
      const timeDiff = Math.abs(rideTimestamp - targetTimestamp);
      return timeDiff <= this.TIME_TOLERANCE * 1000;
    });
  }

  async optimizeRouteMatching(rides, pickupLocation, dropoffLocation) {
    const optimizedRides = [];

    for (const ride of rides) {
      try {
        // è®¡ç®—åŽŸå§‹è·¯çº¿
        const originalRoute = await this.mapsService.calculateRoute(
          ride.departure_location,
          ride.destination_location
        );

        // è®¡ç®—åŒ…å«æŽ¥é€ç‚¹çš„æ–°è·¯çº¿
        const newRoute = await this.mapsService.calculateRoute(
          ride.departure_location,
          ride.destination_location,
          [pickupLocation, dropoffLocation]
        );

        // è®¡ç®—ç»•è¡Œè·ç¦»å’Œæ—¶é—´
        const extraDistance = newRoute.distance - originalRoute.distance;
        const extraTime = newRoute.duration - originalRoute.duration;

        // æ£€æŸ¥æ˜¯å¦åœ¨å¯æŽ¥å—èŒƒå›´å†…
        if (extraDistance <= this.MAX_DETOUR_DISTANCE && extraTime <= 900) {
          // 15åˆ†é’Ÿ
          optimizedRides.push({
            ...ride,
            routeOptimization: {
              originalDistance: originalRoute.distance,
              newDistance: newRoute.distance,
              extraDistance,
              extraTime,
              optimizedRoute: newRoute.waypoints,
            },
          });
        }
      } catch (error) {
        logger.warn(`Route optimization failed for ride ${ride.id}:`, error);
        // å¦‚æžœè·¯çº¿ä¼˜åŒ–å¤±è´¥ï¼Œä»ç„¶åŒ…å«è¯¥æ‹¼è½¦ï¼Œä½†æ ‡è®°ä¸ºæœªä¼˜åŒ–
        optimizedRides.push({
          ...ride,
          routeOptimization: { optimized: false },
        });
      }
    }

    return optimizedRides;
  }

  sortByMatchingScore(rides, searchCriteria) {
    return rides
      .map((ride) => {
        let score = 0;

        // è·ç¦»å¾—åˆ† (æƒé‡: 30%)
        const avgDistance =
          (ride.departure_distance + ride.destination_distance) / 2;
        score += (1 - avgDistance / this.MATCHING_RADIUS) * 30;

        // æ—¶é—´åŒ¹é…å¾—åˆ† (æƒé‡: 25%)
        const timeDiff = Math.abs(
          new Date(ride.departure_time).getTime() -
            new Date(searchCriteria.departureTime).getTime()
        );
        score += (1 - timeDiff / (this.TIME_TOLERANCE * 1000)) * 25;

        // ä»·æ ¼å¾—åˆ† (æƒé‡: 20%)
        if (searchCriteria.maxPrice) {
          score += (1 - ride.price_per_seat / searchCriteria.maxPrice) * 20;
        }

        // å¸æœºè¯„åˆ† (æƒé‡: 15%)
        score += (ride.rating / 5) * 15;

        // è·¯çº¿ä¼˜åŒ–å¾—åˆ† (æƒé‡: 10%)
        if (ride.routeOptimization?.optimized !== false) {
          const detourRatio =
            ride.routeOptimization?.extraDistance /
              ride.routeOptimization?.originalDistance || 0;
          score += (1 - Math.min(detourRatio, 1)) * 10;
        }

        return { ...ride, matchingScore: Math.round(score) };
      })
      .sort((a, b) => b.matchingScore - a.matchingScore);
  }
}
```

### æ‹¼è½¦ API è®¾è®¡

#### 1. å‘å¸ƒæ‹¼è½¦

```javascript
// POST /api/rideshare/rides
const createRide = async (req, res) => {
  try {
    const {
      title,
      description,
      departureLocation,
      destinationLocation,
      departureTime,
      seatsAvailable,
      pricePerSeat,
      vehicleInfo,
      restrictions,
      paymentMethod,
      autoAccept,
      recurringPattern,
    } = req.body;

    const driverId = req.user.userId;

    // 1. è¾“å…¥éªŒè¯
    const validation = validateRideCreation(req.body);
    if (!validation.isValid) {
      return res.status(400).json({
        success: false,
        message: "Invalid input data",
        errors: validation.errors,
      });
    }

    // 2. éªŒè¯å¸æœºèµ„æ ¼
    const driver = await User.findById(driverId);
    if (!driver.drivingLicense || !driver.drivingLicense.verified) {
      return res.status(403).json({
        success: false,
        message: "Valid driving license required to create rides",
      });
    }

    // 3. æ£€æŸ¥æ—¶é—´å†²çª
    const conflicts = await Ride.find({
      driverId,
      status: { $in: ["pending", "confirmed", "ongoing"] },
      departureTime: {
        $gte: new Date(departureTime - 3600000), // 1å°æ—¶å‰
        $lte: new Date(departureTime + 3600000), // 1å°æ—¶åŽ
      },
    });

    if (conflicts.length > 0) {
      return res.status(409).json({
        success: false,
        message: "You have conflicting rides at this time",
      });
    }

    // 4. è·¯çº¿è§„åˆ’å’Œé¢„ä¼°
    const routeInfo = await mapsService.calculateRoute(
      departureLocation,
      destinationLocation
    );

    const estimatedArrival = new Date(
      new Date(departureTime).getTime() + routeInfo.duration * 1000
    );

    // 5. åˆ›å»ºæ‹¼è½¦è®°å½•
    const ride = await Ride.create({
      driverId,
      title,
      description,
      departureLocation,
      destinationLocation,
      departureTime: new Date(departureTime),
      estimatedArrivalTime: estimatedArrival,
      seatsAvailable,
      pricePerSeat,
      vehicleInfo,
      routeInfo,
      restrictions,
      paymentMethod,
      autoAccept,
      recurringPattern,
      status: "pending",
    });

    // 6. è‡ªåŠ¨åŒ¹é…é€šçŸ¥
    await this.notifyPotentialPassengers(ride);

    // 7. è®°å½•æ—¥å¿—
    logger.info("Ride created successfully", {
      rideId: ride.id,
      driverId,
      departure: departureLocation.address,
      destination: destinationLocation.address,
      departureTime,
    });

    res.status(201).json({
      success: true,
      message: "Ride created successfully",
      data: {
        ride: {
          id: ride.id,
          title: ride.title,
          departureLocation: ride.departureLocation,
          destinationLocation: ride.destinationLocation,
          departureTime: ride.departureTime,
          estimatedArrivalTime: ride.estimatedArrivalTime,
          seatsAvailable: ride.seatsAvailable,
          pricePerSeat: ride.pricePerSeat,
          status: ride.status,
        },
      },
    });
  } catch (error) {
    logger.error("Create ride error:", error);
    res.status(500).json({
      success: false,
      message: "Internal server error during ride creation",
    });
  }
};
```

#### 2. æœç´¢æ‹¼è½¦

```javascript
// GET /api/rideshare/search
const searchRides = async (req, res) => {
  try {
    const {
      from_lat,
      from_lng,
      to_lat,
      to_lng,
      departure_time,
      seats = 1,
      max_price,
      sort_by = "relevance",
      page = 1,
      limit = 20,
    } = req.query;

    // 1. å‚æ•°éªŒè¯
    if (!from_lat || !from_lng || !to_lat || !to_lng || !departure_time) {
      return res.status(400).json({
        success: false,
        message: "Missing required search parameters",
      });
    }

    // 2. æž„å»ºæœç´¢æ¡ä»¶
    const searchCriteria = {
      departureLocation: {
        latitude: parseFloat(from_lat),
        longitude: parseFloat(from_lng),
      },
      destinationLocation: {
        latitude: parseFloat(to_lat),
        longitude: parseFloat(to_lng),
      },
      departureTime: new Date(departure_time),
      seatsNeeded: parseInt(seats),
      maxPrice: max_price ? parseFloat(max_price) : null,
    };

    // 3. æ‰§è¡Œæ™ºèƒ½åŒ¹é…
    const matchingService = new RideMatchingService();
    const matchedRides = await matchingService.findMatchingRides(
      searchCriteria
    );

    // 4. åˆ†é¡µå¤„ç†
    const startIndex = (parseInt(page) - 1) * parseInt(limit);
    const endIndex = startIndex + parseInt(limit);
    const paginatedRides = matchedRides.slice(startIndex, endIndex);

    // 5. æ ¼å¼åŒ–å“åº”æ•°æ®
    const formattedRides = paginatedRides.map((ride) => ({
      id: ride.id,
      title: ride.title,
      driver: {
        id: ride.driver_id,
        firstName: ride.first_name,
        lastName: ride.last_name,
        avatarUrl: ride.avatar_url,
        rating: ride.rating,
      },
      departure: ride.departure_location,
      destination: ride.destination_location,
      departureTime: ride.departure_time,
      estimatedArrival: ride.estimated_arrival_time,
      seatsAvailable: ride.seats_available - ride.seats_taken,
      pricePerSeat: ride.price_per_seat,
      vehicleInfo: ride.vehicle_info,
      matchingScore: ride.matchingScore,
      routeOptimization: ride.routeOptimization,
      paymentMethod: ride.payment_method,
    }));

    res.status(200).json({
      success: true,
      data: {
        rides: formattedRides,
        pagination: {
          currentPage: parseInt(page),
          totalPages: Math.ceil(matchedRides.length / parseInt(limit)),
          totalItems: matchedRides.length,
          itemsPerPage: parseInt(limit),
        },
        searchCriteria,
        executionTime: Date.now() - req.startTime,
      },
    });
  } catch (error) {
    logger.error("Search rides error:", error);
    res.status(500).json({
      success: false,
      message: "Internal server error during ride search",
    });
  }
};
```

#### 3. ç”³è¯·åŠ å…¥æ‹¼è½¦

```javascript
// POST /api/rideshare/rides/:rideId/join
const joinRide = async (req, res) => {
  try {
    const { rideId } = req.params;
    const {
      seatsRequested = 1,
      pickupLocation,
      message,
      emergencyContact,
    } = req.body;
    const passengerId = req.user.userId;

    // 1. èŽ·å–æ‹¼è½¦ä¿¡æ¯
    const ride = await Ride.findById(rideId).populate("driverId");
    if (!ride) {
      return res.status(404).json({
        success: false,
        message: "Ride not found",
      });
    }

    // 2. æ£€æŸ¥æ‹¼è½¦çŠ¶æ€
    if (ride.status !== "confirmed") {
      return res.status(400).json({
        success: false,
        message: "Ride is not available for booking",
      });
    }

    // 3. æ£€æŸ¥æ˜¯å¦ä¸ºå¸æœºè‡ªå·±
    if (ride.driverId._id.toString() === passengerId) {
      return res.status(400).json({
        success: false,
        message: "You cannot join your own ride",
      });
    }

    // 4. æ£€æŸ¥åº§ä½å¯ç”¨æ€§
    const availableSeats = ride.seatsAvailable - ride.seatsTaken;
    if (seatsRequested > availableSeats) {
      return res.status(400).json({
        success: false,
        message: `Only ${availableSeats} seats available`,
      });
    }

    // 5. æ£€æŸ¥æ˜¯å¦å·²ç»ç”³è¯·
    const existingRequest = await RideRequest.findOne({
      rideId,
      passengerId,
    });

    if (existingRequest) {
      return res.status(409).json({
        success: false,
        message: "You have already requested to join this ride",
      });
    }

    // 6. åˆ›å»ºæ‹¼è½¦è¯·æ±‚
    const rideRequest = await RideRequest.create({
      rideId,
      passengerId,
      seatsRequested,
      pickupLocation,
      message,
      emergencyContact,
      paymentAmount: ride.pricePerSeat * seatsRequested,
      status: ride.autoAccept ? "accepted" : "pending",
    });

    // 7. å¦‚æžœè‡ªåŠ¨æŽ¥å—ï¼Œæ›´æ–°æ‹¼è½¦åº§ä½
    if (ride.autoAccept) {
      await Ride.updateOne(
        { _id: rideId },
        { $inc: { seatsTaken: seatsRequested } }
      );

      // å‘é€ç¡®è®¤é€šçŸ¥
      await notificationService.sendRideConfirmation({
        recipientId: passengerId,
        rideId,
        driverName: `${ride.driverId.firstName} ${ride.driverId.lastName}`,
      });
    } else {
      // å‘é€è¯·æ±‚é€šçŸ¥ç»™å¸æœº
      await notificationService.sendRideRequest({
        recipientId: ride.driverId._id,
        requestId: rideRequest.id,
        passengerName: `${req.user.firstName} ${req.user.lastName}`,
        rideTitle: ride.title,
      });
    }

    // 8. å®žæ—¶é€šçŸ¥
    const io = req.app.get("io");
    io.to(`user_${ride.driverId._id}`).emit("new_ride_request", {
      requestId: rideRequest.id,
      rideId,
      passenger: {
        id: passengerId,
        name: `${req.user.firstName} ${req.user.lastName}`,
        avatar: req.user.avatarUrl,
      },
      seatsRequested,
      message,
    });

    res.status(201).json({
      success: true,
      message: ride.autoAccept
        ? "Successfully joined the ride"
        : "Join request sent to the driver",
      data: {
        requestId: rideRequest.id,
        status: rideRequest.status,
        paymentAmount: rideRequest.paymentAmount,
        autoAccepted: ride.autoAccept,
      },
    });
  } catch (error) {
    logger.error("Join ride error:", error);
    res.status(500).json({
      success: false,
      message: "Internal server error while joining ride",
    });
  }
};
```

---

## ðŸ›’ å¸‚åœºç³»ç»Ÿ

### å•†å“æœç´¢ä¸ŽæŽ¨èå¼•æ“Ž

```javascript
// åŸºäºŽElasticsearchçš„å•†å“æœç´¢æœåŠ¡
class ProductSearchService {
  constructor() {
    this.elasticClient = new Client({ node: process.env.ELASTICSEARCH_URL });
    this.index = "campus_marketplace";
  }

  async searchProducts(query) {
    const {
      keyword,
      category,
      minPrice,
      maxPrice,
      condition,
      location,
      radius = 10,
      sortBy = "relevance",
      page = 1,
      limit = 20,
      userId,
    } = query;

    try {
      // æž„å»ºElasticsearchæŸ¥è¯¢
      const searchQuery = {
        index: this.index,
        body: {
          query: {
            bool: {
              must: [],
              filter: [],
              should: [],
              must_not: [
                { term: { availability_status: "sold" } },
                { term: { availability_status: "hidden" } },
              ],
            },
          },
          sort: [],
          from: (page - 1) * limit,
          size: limit,
          highlight: {
            fields: {
              title: {},
              description: {},
            },
          },
          aggs: {
            categories: {
              terms: { field: "category.keyword" },
            },
            price_ranges: {
              range: {
                field: "price",
                ranges: [
                  { to: 50 },
                  { from: 50, to: 200 },
                  { from: 200, to: 500 },
                  { from: 500 },
                ],
              },
            },
            conditions: {
              terms: { field: "condition_type.keyword" },
            },
          },
        },
      };

      // å…³é”®è¯æœç´¢
      if (keyword) {
        searchQuery.body.query.bool.must.push({
          multi_match: {
            query: keyword,
            fields: ["title^3", "description^2", "brand^2", "tags"],
            type: "best_fields",
            fuzziness: "AUTO",
          },
        });
      } else {
        searchQuery.body.query.bool.must.push({ match_all: {} });
      }

      // åˆ†ç±»ç­›é€‰
      if (category) {
        searchQuery.body.query.bool.filter.push({
          term: { "category.keyword": category },
        });
      }

      // ä»·æ ¼ç­›é€‰
      if (minPrice || maxPrice) {
        const priceRange = {};
        if (minPrice) priceRange.gte = minPrice;
        if (maxPrice) priceRange.lte = maxPrice;
        searchQuery.body.query.bool.filter.push({
          range: { price: priceRange },
        });
      }

      // å•†å“çŠ¶å†µç­›é€‰
      if (condition) {
        searchQuery.body.query.bool.filter.push({
          term: { "condition_type.keyword": condition },
        });
      }

      // åœ°ç†ä½ç½®ç­›é€‰
      if (location && location.latitude && location.longitude) {
        searchQuery.body.query.bool.filter.push({
          geo_distance: {
            distance: `${radius}km`,
            "location.coordinates": {
              lat: location.latitude,
              lon: location.longitude,
            },
          },
        });

        // æ·»åŠ è·ç¦»æŽ’åº
        searchQuery.body.sort.push({
          _geo_distance: {
            "location.coordinates": {
              lat: location.latitude,
              lon: location.longitude,
            },
            order: "asc",
            unit: "km",
          },
        });
      }

      // ä¸ªæ€§åŒ–æŽ¨èï¼ˆåŸºäºŽç”¨æˆ·åŽ†å²è¡Œä¸ºï¼‰
      if (userId) {
        const userPreferences = await this.getUserPreferences(userId);
        if (userPreferences.length > 0) {
          searchQuery.body.query.bool.should.push({
            terms: {
              "category.keyword": userPreferences,
              boost: 1.2,
            },
          });
        }
      }

      // æŽ’åºé€»è¾‘
      this.applySorting(searchQuery, sortBy);

      // æ‰§è¡Œæœç´¢
      const response = await this.elasticClient.search(searchQuery);

      // æ ¼å¼åŒ–ç»“æžœ
      return this.formatSearchResults(response);
    } catch (error) {
      logger.error("Product search error:", error);
      throw new Error("Search service temporarily unavailable");
    }
  }

  applySorting(searchQuery, sortBy) {
    switch (sortBy) {
      case "price_low":
        searchQuery.body.sort.unshift({ price: { order: "asc" } });
        break;
      case "price_high":
        searchQuery.body.sort.unshift({ price: { order: "desc" } });
        break;
      case "newest":
        searchQuery.body.sort.unshift({ created_at: { order: "desc" } });
        break;
      case "popular":
        searchQuery.body.sort.unshift({
          _script: {
            type: "number",
            script: {
              source:
                'doc["view_count"].value + doc["favorite_count"].value * 2',
            },
            order: "desc",
          },
        });
        break;
      default: // relevance
        searchQuery.body.sort.unshift({ _score: { order: "desc" } });
    }
  }

  async getUserPreferences(userId) {
    // åˆ†æžç”¨æˆ·åŽ†å²æµè§ˆå’Œè´­ä¹°è®°å½•
    const userBehavior = await ProductView.aggregate([
      { $match: { userId: new ObjectId(userId) } },
      { $group: { _id: "$category", count: { $sum: 1 } } },
      { $sort: { count: -1 } },
      { $limit: 3 },
    ]);

    return userBehavior.map((item) => item._id);
  }

  formatSearchResults(response) {
    return {
      products: response.body.hits.hits.map((hit) => ({
        id: hit._source.id,
        title: hit._source.title,
        description: hit._source.description,
        price: hit._source.price,
        originalPrice: hit._source.original_price,
        category: hit._source.category,
        condition: hit._source.condition_type,
        images: hit._source.images,
        location: hit._source.location,
        seller: hit._source.seller,
        createdAt: hit._source.created_at,
        distance: hit.sort ? hit.sort[hit.sort.length - 1] : null,
        highlights: hit.highlight,
        score: hit._score,
      })),
      total: response.body.hits.total.value,
      aggregations: {
        categories: response.body.aggregations.categories.buckets,
        priceRanges: response.body.aggregations.price_ranges.buckets,
        conditions: response.body.aggregations.conditions.buckets,
      },
      took: response.body.took,
    };
  }
}
```

### å¸‚åœº API è®¾è®¡

#### 1. å‘å¸ƒå•†å“

```javascript
// POST /api/marketplace/products
const createProduct = async (req, res) => {
  try {
    const {
      title,
      description,
      category,
      condition,
      price,
      originalPrice,
      brand,
      specifications,
      tags,
      deliveryOptions,
      paymentMethods,
      negotiable,
      expiresAt,
    } = req.body;

    const sellerId = req.user.userId;

    // 1. è¾“å…¥éªŒè¯
    const validation = validateProductCreation(req.body);
    if (!validation.isValid) {
      return res.status(400).json({
        success: false,
        message: "Invalid input data",
        errors: validation.errors,
      });
    }

    // 2. æ£€æŸ¥ç”¨æˆ·å‘å¸ƒé™åˆ¶
    const userProductCount = await Product.countDocuments({
      sellerId,
      availabilityStatus: { $in: ["available", "reserved"] },
    });

    if (userProductCount >= 20) {
      return res.status(400).json({
        success: false,
        message: "Maximum 20 active products allowed per user",
      });
    }

    // 3. å¤„ç†ä¸Šä¼ çš„å›¾ç‰‡
    let imageUrls = [];
    if (req.files && req.files.length > 0) {
      imageUrls = await Promise.all(
        req.files.map((file) =>
          storageService.uploadProductImage(file, sellerId)
        )
      );
    }

    // 4. èŽ·å–ç”¨æˆ·ä½ç½®ï¼ˆé»˜è®¤ä½¿ç”¨ç”¨æˆ·è®¾ç½®çš„ä½ç½®ï¼‰
    const user = await User.findById(sellerId).select("location university");
    const productLocation = user.location || {
      address: user.university,
      latitude: null,
      longitude: null,
    };

    // 5. åˆ›å»ºå•†å“è®°å½•
    const product = await Product.create({
      sellerId,
      title,
      description,
      category,
      conditionType: condition,
      price,
      originalPrice,
      brand,
      specifications,
      images: imageUrls,
      tags: tags || [],
      location: productLocation,
      deliveryOptions: deliveryOptions || { pickup: true },
      paymentMethods: paymentMethods || ["cash"],
      negotiable: negotiable !== false,
      expiresAt: expiresAt ? new Date(expiresAt) : null,
      availabilityStatus: "available",
    });

    // 6. ç´¢å¼•åˆ°Elasticsearch
    await searchService.indexProduct(product);

    // 7. å‘é€æŽ¨èé€šçŸ¥ç»™æ½œåœ¨ä¹°å®¶
    await this.notifyInterestedUsers(product);

    // 8. è®°å½•æ—¥å¿—
    logger.info("Product created successfully", {
      productId: product.id,
      sellerId,
      title: product.title,
      category: product.category,
      price: product.price,
    });

    res.status(201).json({
      success: true,
      message: "Product listed successfully",
      data: {
        product: {
          id: product.id,
          title: product.title,
          description: product.description,
          category: product.category,
          condition: product.conditionType,
          price: product.price,
          images: product.images,
          createdAt: product.createdAt,
        },
      },
    });
  } catch (error) {
    logger.error("Create product error:", error);
    res.status(500).json({
      success: false,
      message: "Internal server error during product creation",
    });
  }
};
```

#### 2. å•†å“äº¤æ˜“æµç¨‹

```javascript
// POST /api/marketplace/products/:productId/purchase
const purchaseProduct = async (req, res) => {
  try {
    const { productId } = req.params;
    const { paymentMethod, deliveryOption, message } = req.body;
    const buyerId = req.user.userId;

    // 1. èŽ·å–å•†å“ä¿¡æ¯
    const product = await Product.findById(productId).populate("sellerId");
    if (!product) {
      return res.status(404).json({
        success: false,
        message: "Product not found",
      });
    }

    // 2. æ£€æŸ¥å•†å“çŠ¶æ€
    if (product.availabilityStatus !== "available") {
      return res.status(400).json({
        success: false,
        message: "Product is no longer available",
      });
    }

    // 3. æ£€æŸ¥æ˜¯å¦ä¸ºè‡ªå·±çš„å•†å“
    if (product.sellerId._id.toString() === buyerId) {
      return res.status(400).json({
        success: false,
        message: "You cannot purchase your own product",
      });
    }

    // 4. éªŒè¯æ”¯ä»˜æ–¹å¼
    if (!product.paymentMethods.includes(paymentMethod)) {
      return res.status(400).json({
        success: false,
        message: "Selected payment method not accepted by seller",
      });
    }

    // 5. å¼€å§‹äº‹åŠ¡å¤„ç†
    const session = await mongoose.startSession();
    session.startTransaction();

    try {
      // æ›´æ–°å•†å“çŠ¶æ€ä¸ºå·²ä¿ç•™
      await Product.updateOne(
        { _id: productId, availabilityStatus: "available" },
        {
          availabilityStatus: "reserved",
          reservedFor: buyerId,
          reservedAt: new Date(),
        },
        { session }
      );

      // åˆ›å»ºäº¤æ˜“è®°å½•
      const transaction = await Transaction.create(
        [
          {
            productId,
            buyerId,
            sellerId: product.sellerId._id,
            transactionType: "product_sale",
            amount: product.price,
            paymentMethod,
            status: paymentMethod === "cash" ? "pending" : "processing",
            metadata: {
              deliveryOption,
              buyerMessage: message,
            },
          },
        ],
        { session }
      );

      // å¦‚æžœæ˜¯åœ¨çº¿æ”¯ä»˜ï¼Œåˆ›å»ºæ”¯ä»˜è®¢å•
      let paymentOrderId = null;
      if (paymentMethod !== "cash") {
        paymentOrderId = await paymentService.createPaymentOrder({
          transactionId: transaction[0].id,
          amount: product.price,
          paymentMethod,
          description: `Purchase: ${product.title}`,
          buyerId,
          sellerId: product.sellerId._id,
        });

        await Transaction.updateOne(
          { _id: transaction[0]._id },
          { paymentGatewayId: paymentOrderId },
          { session }
        );
      }

      await session.commitTransaction();

      // 6. å‘é€é€šçŸ¥ç»™å–å®¶
      await notificationService.sendPurchaseNotification({
        recipientId: product.sellerId._id,
        productTitle: product.title,
        buyerName: `${req.user.firstName} ${req.user.lastName}`,
        transactionId: transaction[0].id,
        paymentMethod,
        deliveryOption,
      });

      // 7. å®žæ—¶é€šçŸ¥
      const io = req.app.get("io");
      io.to(`user_${product.sellerId._id}`).emit("product_purchase", {
        productId,
        productTitle: product.title,
        buyer: {
          id: buyerId,
          name: `${req.user.firstName} ${req.user.lastName}`,
          avatar: req.user.avatarUrl,
        },
        transactionId: transaction[0].id,
        amount: product.price,
        paymentMethod,
      });

      res.status(200).json({
        success: true,
        message: "Purchase initiated successfully",
        data: {
          transactionId: transaction[0].id,
          paymentOrderId,
          amount: product.price,
          paymentMethod,
          status: transaction[0].status,
          nextStep:
            paymentMethod === "cash"
              ? "Contact seller to arrange payment and delivery"
              : "Complete payment to confirm purchase",
        },
      });
    } catch (error) {
      await session.abortTransaction();
      throw error;
    } finally {
      session.endSession();
    }
  } catch (error) {
    logger.error("Purchase product error:", error);
    res.status(500).json({
      success: false,
      message: "Internal server error during purchase",
    });
  }
};
```

---

## ðŸ”” é€šçŸ¥ç³»ç»Ÿ

### å¤šæ¸ é“é€šçŸ¥æœåŠ¡

```javascript
// é€šçŸ¥æœåŠ¡ä¸»ç±»
class NotificationService {
  constructor() {
    this.channels = {
      push: new PushNotificationChannel(),
      email: new EmailNotificationChannel(),
      sms: new SMSNotificationChannel(),
      inApp: new InAppNotificationChannel(),
    };
    this.queue = new Bull("notification-queue", {
      redis: { host: process.env.REDIS_HOST, port: process.env.REDIS_PORT },
    });
    this.setupWorkers();
  }

  async sendNotification(notification) {
    const {
      userId,
      type,
      title,
      content,
      data = {},
      priority = "medium",
      deliveryMethods = ["in_app"],
      scheduledFor = null,
    } = notification;

    try {
      // 1. åˆ›å»ºé€šçŸ¥è®°å½•
      const notificationRecord = await Notification.create({
        userId,
        type,
        title,
        content,
        data,
        priority,
        deliveryMethod: deliveryMethods,
        scheduledFor: scheduledFor ? new Date(scheduledFor) : null,
        status: "unread",
      });

      // 2. æ ¹æ®ç”¨æˆ·åå¥½è¿‡æ»¤å‘é€æ¸ é“
      const userPreferences = await this.getUserNotificationPreferences(userId);
      const enabledMethods = deliveryMethods.filter(
        (method) => userPreferences[method] !== false
      );

      // 3. ç«‹å³å‘é€æˆ–åŠ å…¥é˜Ÿåˆ—
      if (scheduledFor) {
        await this.scheduleNotification(notificationRecord, enabledMethods);
      } else {
        await this.deliverNotification(notificationRecord, enabledMethods);
      }

      return notificationRecord;
    } catch (error) {
      logger.error("Send notification error:", error);
      throw error;
    }
  }

  async deliverNotification(notification, methods) {
    const deliveryPromises = methods.map((method) => {
      const channel = this.channels[method];
      if (channel) {
        return channel.send(notification).catch((error) => {
          logger.error(`${method} notification delivery failed:`, error);
          return { method, success: false, error: error.message };
        });
      }
    });

    const results = await Promise.allSettled(deliveryPromises);

    // æ›´æ–°å‘é€çŠ¶æ€
    await Notification.updateOne(
      { _id: notification._id },
      {
        sentAt: new Date(),
        deliveryResults: results,
      }
    );

    return results;
  }

  async getUserNotificationPreferences(userId) {
    // ä»Žç”¨æˆ·è®¾ç½®ä¸­èŽ·å–é€šçŸ¥åå¥½
    const user = await User.findById(userId).select("notificationPreferences");
    return (
      user.notificationPreferences || {
        push: true,
        email: true,
        sms: false,
        in_app: true,
      }
    );
  }

  // é¢„å®šä¹‰çš„é€šçŸ¥æ¨¡æ¿
  async sendRideRequest(data) {
    return this.sendNotification({
      userId: data.recipientId,
      type: "ride_request",
      title: "æ–°çš„æ‹¼è½¦ç”³è¯·",
      content: `${data.passengerName} ç”³è¯·åŠ å…¥æ‚¨çš„æ‹¼è½¦ã€Œ${data.rideTitle}ã€`,
      data: {
        requestId: data.requestId,
        passengerName: data.passengerName,
        rideTitle: data.rideTitle,
      },
      priority: "high",
      deliveryMethods: ["push", "in_app"],
      actionUrl: `/rideshare/requests/${data.requestId}`,
    });
  }

  async sendPurchaseNotification(data) {
    return this.sendNotification({
      userId: data.recipientId,
      type: "product_inquiry",
      title: "å•†å“è´­ä¹°é€šçŸ¥",
      content: `${data.buyerName} æƒ³è¦è´­ä¹°æ‚¨çš„å•†å“ã€Œ${data.productTitle}ã€`,
      data: {
        productTitle: data.productTitle,
        buyerName: data.buyerName,
        transactionId: data.transactionId,
        paymentMethod: data.paymentMethod,
      },
      priority: "high",
      deliveryMethods: ["push", "email", "in_app"],
      actionUrl: `/marketplace/transactions/${data.transactionId}`,
    });
  }
}

// æŽ¨é€é€šçŸ¥æ¸ é“
class PushNotificationChannel {
  constructor() {
    this.fcm = admin.messaging();
  }

  async send(notification) {
    try {
      // èŽ·å–ç”¨æˆ·è®¾å¤‡tokens
      const user = await User.findById(notification.userId);
      const deviceTokens = user.deviceTokens || [];

      if (deviceTokens.length === 0) {
        return { success: false, reason: "No device tokens" };
      }

      const message = {
        notification: {
          title: notification.title,
          body: notification.content,
        },
        data: {
          type: notification.type,
          ...notification.data,
        },
        tokens: deviceTokens,
      };

      const response = await this.fcm.sendMulticast(message);

      // æ¸…ç†æ— æ•ˆçš„tokens
      if (response.failureCount > 0) {
        await this.cleanupInvalidTokens(
          notification.userId,
          response.responses,
          deviceTokens
        );
      }

      return {
        success: true,
        successCount: response.successCount,
        failureCount: response.failureCount,
      };
    } catch (error) {
      logger.error("Push notification error:", error);
      throw error;
    }
  }

  async cleanupInvalidTokens(userId, responses, tokens) {
    const invalidTokens = [];
    responses.forEach((response, index) => {
      if (
        !response.success &&
        (response.error.code === "messaging/invalid-registration-token" ||
          response.error.code === "messaging/registration-token-not-registered")
      ) {
        invalidTokens.push(tokens[index]);
      }
    });

    if (invalidTokens.length > 0) {
      await User.updateOne(
        { _id: userId },
        { $pullAll: { deviceTokens: invalidTokens } }
      );
    }
  }
}
```

### å®žæ—¶é€šçŸ¥ API

```javascript
// WebSocket é€šçŸ¥å¤„ç†
class SocketNotificationHandler {
  constructor(io) {
    this.io = io;
    this.userSockets = new Map(); // userId -> Set of socket IDs
  }

  handleConnection(socket) {
    socket.on("authenticate", async (data) => {
      try {
        const { accessToken } = data;
        const decoded = jwt.verify(accessToken, process.env.JWT_ACCESS_SECRET);
        const userId = decoded.userId;

        // å°†socketåŠ å…¥ç”¨æˆ·æˆ¿é—´
        socket.join(`user_${userId}`);
        socket.userId = userId;

        // è®°å½•ç”¨æˆ·socketè¿žæŽ¥
        if (!this.userSockets.has(userId)) {
          this.userSockets.set(userId, new Set());
        }
        this.userSockets.get(userId).add(socket.id);

        // æ›´æ–°ç”¨æˆ·åœ¨çº¿çŠ¶æ€
        await User.updateOne(
          { _id: userId },
          {
            lastActive: new Date(),
            isOnline: true,
          }
        );

        // å‘é€æœªè¯»é€šçŸ¥
        await this.sendUnreadNotifications(userId);

        socket.emit("authenticated", { success: true });
      } catch (error) {
        socket.emit("auth_error", { message: "Invalid token" });
        socket.disconnect();
      }
    });

    socket.on("mark_notification_read", async (data) => {
      try {
        const { notificationId } = data;
        await Notification.updateOne(
          { _id: notificationId, userId: socket.userId },
          {
            status: "read",
            readAt: new Date(),
          }
        );

        socket.emit("notification_marked_read", { notificationId });
      } catch (error) {
        socket.emit("error", {
          message: "Failed to mark notification as read",
        });
      }
    });

    socket.on("disconnect", async () => {
      if (socket.userId) {
        const userSockets = this.userSockets.get(socket.userId);
        if (userSockets) {
          userSockets.delete(socket.id);

          // å¦‚æžœç”¨æˆ·æ²¡æœ‰å…¶ä»–è¿žæŽ¥ï¼Œæ ‡è®°ä¸ºç¦»çº¿
          if (userSockets.size === 0) {
            this.userSockets.delete(socket.userId);
            await User.updateOne(
              { _id: socket.userId },
              {
                isOnline: false,
                lastActive: new Date(),
              }
            );
          }
        }
      }
    });
  }

  async sendUnreadNotifications(userId) {
    const unreadNotifications = await Notification.find({
      userId,
      status: "unread",
    })
      .sort({ createdAt: -1 })
      .limit(50);

    if (unreadNotifications.length > 0) {
      this.io.to(`user_${userId}`).emit("unread_notifications", {
        notifications: unreadNotifications,
        count: unreadNotifications.length,
      });
    }
  }

  // å‘ç‰¹å®šç”¨æˆ·å‘é€å®žæ—¶é€šçŸ¥
  async sendRealTimeNotification(userId, notification) {
    this.io.to(`user_${userId}`).emit("new_notification", {
      id: notification._id,
      type: notification.type,
      title: notification.title,
      content: notification.content,
      data: notification.data,
      priority: notification.priority,
      createdAt: notification.createdAt,
    });
  }
}
```

---

## ðŸ“ æ–‡ä»¶ç®¡ç†ç³»ç»Ÿ

### æ–‡ä»¶ä¸Šä¼ æœåŠ¡

```javascript
// æ–‡ä»¶ä¸Šä¼ å’Œå¤„ç†æœåŠ¡
class FileUploadService {
  constructor() {
    this.storage = this.initializeStorage();
    this.imageProcessor = sharp;
    this.allowedTypes = {
      image: ["jpg", "jpeg", "png", "gif", "webp"],
      document: ["pdf", "doc", "docx", "txt"],
      video: ["mp4", "avi", "mov", "wmv"],
    };
    this.maxFileSizes = {
      image: 10 * 1024 * 1024, // 10MB
      document: 20 * 1024 * 1024, // 20MB
      video: 100 * 1024 * 1024, // 100MB
    };
  }

  initializeStorage() {
    if (process.env.STORAGE_TYPE === "s3") {
      return new S3Storage({
        bucket: process.env.AWS_S3_BUCKET,
        region: process.env.AWS_REGION,
        accessKeyId: process.env.AWS_ACCESS_KEY_ID,
        secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
      });
    } else {
      return new LocalStorage({
        basePath: process.env.UPLOAD_PATH || "./uploads",
      });
    }
  }

  async uploadFile(file, options = {}) {
    const {
      userId,
      purpose,
      relatedId,
      relatedType,
      generateThumbnail = false,
      allowedTypes,
      maxSize,
    } = options;

    try {
      // 1. æ–‡ä»¶éªŒè¯
      const validation = await this.validateFile(file, {
        allowedTypes,
        maxSize,
      });
      if (!validation.valid) {
        throw new Error(validation.error);
      }

      // 2. ç”Ÿæˆå”¯ä¸€æ–‡ä»¶å
      const fileExtension = path.extname(file.originalname).toLowerCase();
      const fileName = `${uuid.v4()}${fileExtension}`;
      const filePath = this.generateFilePath(userId, purpose, fileName);

      // 3. å¤„ç†å›¾ç‰‡ï¼ˆå¦‚æžœéœ€è¦ï¼‰
      let processedFile = file;
      let thumbnailPath = null;

      if (this.isImage(fileExtension)) {
        processedFile = await this.processImage(file);

        if (generateThumbnail) {
          thumbnailPath = await this.generateThumbnail(processedFile, filePath);
        }
      }

      // 4. ä¸Šä¼ æ–‡ä»¶
      const uploadResult = await this.storage.upload(processedFile, filePath);

      // 5. ä¿å­˜æ–‡ä»¶è®°å½•
      const fileRecord = await FileUpload.create({
        userId,
        filename: fileName,
        originalFilename: file.originalname,
        fileType: file.mimetype,
        fileSize: processedFile.size,
        storagePath: filePath,
        publicUrl: uploadResult.url,
        thumbnailUrl: thumbnailPath,
        purpose,
        relatedId,
        relatedType,
        processingStatus: "completed",
        metadata: {
          dimensions: processedFile.dimensions,
          uploadMethod: "direct",
        },
      });

      return {
        success: true,
        file: {
          id: fileRecord.id,
          filename: fileRecord.filename,
          url: fileRecord.publicUrl,
          thumbnailUrl: fileRecord.thumbnailUrl,
          size: fileRecord.fileSize,
          type: fileRecord.fileType,
        },
      };
    } catch (error) {
      logger.error("File upload error:", error);
      throw error;
    }
  }

  async validateFile(file, options = {}) {
    const { allowedTypes, maxSize } = options;

    // æ£€æŸ¥æ–‡ä»¶å¤§å°
    const fileSizeLimit = maxSize || this.maxFileSizes.image;
    if (file.size > fileSizeLimit) {
      return {
        valid: false,
        error: `File size exceeds limit of ${fileSizeLimit / 1024 / 1024}MB`,
      };
    }

    // æ£€æŸ¥æ–‡ä»¶ç±»åž‹
    const fileExtension = path
      .extname(file.originalname)
      .toLowerCase()
      .slice(1);
    const allowedExtensions = allowedTypes || this.allowedTypes.image;

    if (!allowedExtensions.includes(fileExtension)) {
      return {
        valid: false,
        error: `File type not allowed. Allowed types: ${allowedExtensions.join(
          ", "
        )}`,
      };
    }

    // æ£€æŸ¥æ–‡ä»¶å†…å®¹ï¼ˆé˜²æ­¢æ¶æ„æ–‡ä»¶ï¼‰
    const contentValidation = await this.validateFileContent(file);
    if (!contentValidation.valid) {
      return contentValidation;
    }

    return { valid: true };
  }

  async processImage(file) {
    try {
      const image = this.imageProcessor(file.buffer);
      const metadata = await image.metadata();

      // å›¾ç‰‡åŽ‹ç¼©å’Œä¼˜åŒ–
      let processed = image;

      // é™åˆ¶æœ€å¤§å°ºå¯¸
      if (metadata.width > 2048 || metadata.height > 2048) {
        processed = processed.resize(2048, 2048, {
          fit: "inside",
          withoutEnlargement: true,
        });
      }

      // åŽ‹ç¼©è´¨é‡
      if (file.mimetype === "image/jpeg") {
        processed = processed.jpeg({ quality: 85, progressive: true });
      } else if (file.mimetype === "image/png") {
        processed = processed.png({ compressionLevel: 9 });
      } else if (file.mimetype === "image/webp") {
        processed = processed.webp({ quality: 85 });
      }

      const buffer = await processed.toBuffer();
      const processedMetadata = await this.imageProcessor(buffer).metadata();

      return {
        ...file,
        buffer,
        size: buffer.length,
        dimensions: {
          width: processedMetadata.width,
          height: processedMetadata.height,
        },
      };
    } catch (error) {
      logger.error("Image processing error:", error);
      throw new Error("Failed to process image");
    }
  }

  async generateThumbnail(file, originalPath) {
    try {
      const thumbnailBuffer = await this.imageProcessor(file.buffer)
        .resize(300, 300, {
          fit: "cover",
          position: "center",
        })
        .jpeg({ quality: 80 })
        .toBuffer();

      const thumbnailPath = originalPath.replace(/(\.[^.]+)$/, "_thumb$1");
      const uploadResult = await this.storage.upload(
        {
          buffer: thumbnailBuffer,
          mimetype: "image/jpeg",
        },
        thumbnailPath
      );

      return uploadResult.url;
    } catch (error) {
      logger.error("Thumbnail generation error:", error);
      return null;
    }
  }

  generateFilePath(userId, purpose, filename) {
    const date = new Date();
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");

    return `${purpose}/${userId}/${year}/${month}/${filename}`;
  }

  isImage(extension) {
    return this.allowedTypes.image.includes(extension.slice(1));
  }

  async validateFileContent(file) {
    // ç®€å•çš„æ–‡ä»¶å¤´éªŒè¯
    const fileSignatures = {
      jpg: [0xff, 0xd8, 0xff],
      jpeg: [0xff, 0xd8, 0xff],
      png: [0x89, 0x50, 0x4e, 0x47],
      gif: [0x47, 0x49, 0x46, 0x38],
      pdf: [0x25, 0x50, 0x44, 0x46],
    };

    const extension = path.extname(file.originalname).toLowerCase().slice(1);
    const expectedSignature = fileSignatures[extension];

    if (expectedSignature) {
      const fileHeader = Array.from(
        file.buffer.slice(0, expectedSignature.length)
      );
      const signatureMatch = expectedSignature.every(
        (byte, index) => byte === fileHeader[index]
      );

      if (!signatureMatch) {
        return {
          valid: false,
          error: "File content does not match file extension",
        };
      }
    }

    return { valid: true };
  }
}
```

### æ–‡ä»¶ç®¡ç† API

```javascript
// POST /api/upload/image
const uploadImage = async (req, res) => {
  try {
    const { purpose, relatedId, relatedType } = req.body;
    const userId = req.user.userId;

    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: "No file uploaded",
      });
    }

    // éªŒè¯ç”¨é€”
    const validPurposes = ["avatar", "product_image", "chat_media", "document"];
    if (!validPurposes.includes(purpose)) {
      return res.status(400).json({
        success: false,
        message: "Invalid file purpose",
      });
    }

    // æƒé™æ£€æŸ¥
    if (relatedId && relatedType) {
      const hasPermission = await checkFileUploadPermission(
        userId,
        relatedType,
        relatedId
      );
      if (!hasPermission) {
        return res.status(403).json({
          success: false,
          message: "Permission denied",
        });
      }
    }

    const uploadService = new FileUploadService();
    const result = await uploadService.uploadFile(req.file, {
      userId,
      purpose,
      relatedId,
      relatedType,
      generateThumbnail: purpose === "product_image" || purpose === "avatar",
      allowedTypes: ["jpg", "jpeg", "png", "gif", "webp"],
      maxSize: 10 * 1024 * 1024, // 10MB
    });

    // å¦‚æžœæ˜¯å¤´åƒæ›´æ–°ï¼ŒåŒæ­¥æ›´æ–°ç”¨æˆ·è®°å½•
    if (purpose === "avatar") {
      await User.updateOne({ _id: userId }, { avatarUrl: result.file.url });
    }

    res.status(200).json({
      success: true,
      message: "File uploaded successfully",
      data: result.file,
    });
  } catch (error) {
    logger.error("Upload image error:", error);
    res.status(500).json({
      success: false,
      message: error.message || "File upload failed",
    });
  }
};

// GET /api/upload/files/:fileId
const getFile = async (req, res) => {
  try {
    const { fileId } = req.params;
    const userId = req.user.userId;

    const file = await FileUpload.findById(fileId);
    if (!file) {
      return res.status(404).json({
        success: false,
        message: "File not found",
      });
    }

    // æƒé™æ£€æŸ¥
    const hasAccess = await checkFileAccess(userId, file);
    if (!hasAccess) {
      return res.status(403).json({
        success: false,
        message: "Access denied",
      });
    }

    // è®°å½•æ–‡ä»¶è®¿é—®
    await FileUpload.updateOne({ _id: fileId }, { $inc: { accessCount: 1 } });

    res.status(200).json({
      success: true,
      data: {
        id: file.id,
        filename: file.filename,
        originalFilename: file.originalFilename,
        url: file.publicUrl,
        thumbnailUrl: file.thumbnailUrl,
        fileSize: file.fileSize,
        fileType: file.fileType,
        createdAt: file.createdAt,
      },
    });
  } catch (error) {
    logger.error("Get file error:", error);
    res.status(500).json({
      success: false,
      message: "Failed to retrieve file",
    });
  }
};

// DELETE /api/upload/files/:fileId
const deleteFile = async (req, res) => {
  try {
    const { fileId } = req.params;
    const userId = req.user.userId;

    const file = await FileUpload.findById(fileId);
    if (!file) {
      return res.status(404).json({
        success: false,
        message: "File not found",
      });
    }

    // æƒé™æ£€æŸ¥ - åªæœ‰æ–‡ä»¶æ‰€æœ‰è€…æˆ–ç®¡ç†å‘˜å¯ä»¥åˆ é™¤
    if (file.userId.toString() !== userId && req.user.role !== "admin") {
      return res.status(403).json({
        success: false,
        message: "Permission denied",
      });
    }

    // ä»Žå­˜å‚¨æœåŠ¡åˆ é™¤æ–‡ä»¶
    const storage = new FileUploadService().storage;
    await storage.delete(file.storagePath);

    // å¦‚æžœæœ‰ç¼©ç•¥å›¾ä¹Ÿåˆ é™¤
    if (file.thumbnailUrl) {
      const thumbnailPath = file.storagePath.replace(/(\.[^.]+)$/, "_thumb$1");
      await storage.delete(thumbnailPath);
    }

    // ä»Žæ•°æ®åº“åˆ é™¤è®°å½•
    await FileUpload.deleteOne({ _id: fileId });

    res.status(200).json({
      success: true,
      message: "File deleted successfully",
    });
  } catch (error) {
    logger.error("Delete file error:", error);
    res.status(500).json({
      success: false,
      message: "Failed to delete file",
    });
  }
};
```

---

## âš¡ æ€§èƒ½ä¼˜åŒ–

### æ•°æ®åº“ä¼˜åŒ–ç­–ç•¥

```javascript
// æ•°æ®åº“è¿žæŽ¥æ± é…ç½®
const dbConfig = {
  host: process.env.DB_HOST,
  port: process.env.DB_PORT,
  database: process.env.DB_NAME,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  pool: {
    min: 5,
    max: 20,
    acquire: 60000,
    idle: 10000,
  },
  dialectOptions: {
    options: {
      requestTimeout: 30000,
      enableArithAbort: true,
    },
  },
};

// æŸ¥è¯¢ä¼˜åŒ–ç¤ºä¾‹
class OptimizedQueries {
  // æ‹¼è½¦æœç´¢ä¼˜åŒ– - ä½¿ç”¨ç©ºé—´ç´¢å¼•
  static async searchRidesOptimized(criteria) {
    const {
      departureLocation,
      destinationLocation,
      departureTime,
      radius = 5000,
    } = criteria;

    // ä½¿ç”¨ PostGIS çš„ç©ºé—´æŸ¥è¯¢
    const query = `
      WITH nearby_departures AS (
        SELECT r.*, 
               ST_Distance(
                 ST_Point($1, $2)::geography,
                 ST_Point((departure_location->>'longitude')::float, 
                         (departure_location->>'latitude')::float)::geography
               ) as departure_distance
        FROM rides r
        WHERE ST_DWithin(
          ST_Point($1, $2)::geography,
          ST_Point((departure_location->>'longitude')::float, 
                  (departure_location->>'latitude')::float)::geography,
          $5
        )
        AND r.status = 'confirmed'
        AND r.seats_available > r.seats_taken
        AND r.departure_time BETWEEN $6 AND $7
      ),
      nearby_destinations AS (
        SELECT nd.*,
               ST_Distance(
                 ST_Point($3, $4)::geography,
                 ST_Point((destination_location->>'longitude')::float, 
                         (destination_location->>'latitude')::float)::geography
               ) as destination_distance
        FROM nearby_departures nd
        WHERE ST_DWithin(
          ST_Point($3, $4)::geography,
          ST_Point((destination_location->>'longitude')::float, 
                  (destination_location->>'latitude')::float)::geography,
          $5
        )
      )
      SELECT * FROM nearby_destinations
      ORDER BY departure_distance + destination_distance
      LIMIT 50;
    `;

    const timeStart = new Date(departureTime - 3600000); // 1å°æ—¶å‰
    const timeEnd = new Date(departureTime + 3600000); // 1å°æ—¶åŽ

    return await db.query(query, [
      departureLocation.longitude,
      departureLocation.latitude,
      destinationLocation.longitude,
      destinationLocation.latitude,
      radius,
      timeStart,
      timeEnd,
    ]);
  }

  // å•†å“æœç´¢ä¼˜åŒ– - å…¨æ–‡æœç´¢ + åœ°ç†ä½ç½®
  static async searchProductsOptimized(criteria) {
    const {
      keyword,
      category,
      location,
      radius = 10000,
      minPrice,
      maxPrice,
      limit = 20,
      offset = 0,
    } = criteria;

    let query = `
      SELECT p.*, u.first_name, u.last_name, u.avatar_url,
             ts_rank(search_vector, plainto_tsquery($1)) as relevance_score
    `;

    if (location) {
      query += `,
             ST_Distance(
               ST_Point($${paramCount}, $${paramCount + 1})::geography,
               ST_Point((location->>'longitude')::float, 
                       (location->>'latitude')::float)::geography
             ) as distance`;
    }

    query += `
      FROM products p
      JOIN users u ON p.seller_id = u.id
      WHERE p.availability_status = 'available'
    `;

    const queryParams = [];
    let paramCount = 1;

    // å…¨æ–‡æœç´¢
    if (keyword) {
      queryParams.push(keyword);
    } else {
      queryParams.push("");
    }

    // åœ°ç†ä½ç½®ç­›é€‰
    if (location) {
      query += ` AND ST_DWithin(
        ST_Point($${++paramCount}, $${++paramCount})::geography,
        ST_Point((location->>'longitude')::float, 
                (location->>'latitude')::float)::geography,
        $${++paramCount}
      )`;
      queryParams.push(location.longitude, location.latitude, radius);
    }

    // åˆ†ç±»ç­›é€‰
    if (category) {
      query += ` AND p.category = $${++paramCount}`;
      queryParams.push(category);
    }

    // ä»·æ ¼ç­›é€‰
    if (minPrice) {
      query += ` AND p.price >= $${++paramCount}`;
      queryParams.push(minPrice);
    }
    if (maxPrice) {
      query += ` AND p.price <= $${++paramCount}`;
      queryParams.push(maxPrice);
    }

    // æŽ’åº
    if (keyword) {
      query += " ORDER BY relevance_score DESC";
    } else if (location) {
      query += " ORDER BY distance ASC";
    } else {
      query += " ORDER BY p.created_at DESC";
    }

    // åˆ†é¡µ
    query += ` LIMIT $${++paramCount} OFFSET $${++paramCount}`;
    queryParams.push(limit, offset);

    return await db.query(query, queryParams);
  }
}
```

### ç¼“å­˜ç­–ç•¥

```javascript
// Redisç¼“å­˜ç®¡ç†
class CacheManager {
  constructor() {
    this.redis = new Redis(process.env.REDIS_URL);
    this.defaultTTL = 3600; // 1å°æ—¶
  }

  // æ‹¼è½¦æœç´¢ç»“æžœç¼“å­˜
  async getCachedRideSearch(searchKey) {
    const cacheKey = `ride_search:${searchKey}`;
    const cached = await this.redis.get(cacheKey);

    if (cached) {
      return JSON.parse(cached);
    }
    return null;
  }

  async setCachedRideSearch(searchKey, results, ttl = 300) {
    // 5åˆ†é’Ÿ
    const cacheKey = `ride_search:${searchKey}`;
    await this.redis.setex(cacheKey, ttl, JSON.stringify(results));
  }

  // å•†å“è¯¦æƒ…ç¼“å­˜
  async getCachedProduct(productId) {
    const cacheKey = `product:${productId}`;
    const cached = await this.redis.get(cacheKey);

    if (cached) {
      return JSON.parse(cached);
    }
    return null;
  }

  async setCachedProduct(productId, product, ttl = 1800) {
    // 30åˆ†é’Ÿ
    const cacheKey = `product:${productId}`;
    await this.redis.setex(cacheKey, ttl, JSON.stringify(product));
  }

  // æ¸…é™¤ç›¸å…³ç¼“å­˜
  async invalidateProductCache(productId) {
    const patterns = [
      `product:${productId}`,
      `product_search:*`,
      `user_products:*`,
    ];

    for (const pattern of patterns) {
      const keys = await this.redis.keys(pattern);
      if (keys.length > 0) {
        await this.redis.del(...keys);
      }
    }
  }

  // ç”¨æˆ·ä¼šè¯ç¼“å­˜
  async getUserSession(userId) {
    const cacheKey = `user_session:${userId}`;
    const session = await this.redis.get(cacheKey);
    return session ? JSON.parse(session) : null;
  }

  async setUserSession(userId, sessionData, ttl = 7200) {
    // 2å°æ—¶
    const cacheKey = `user_session:${userId}`;
    await this.redis.setex(cacheKey, ttl, JSON.stringify(sessionData));
  }

  // çƒ­é—¨å•†å“ç¼“å­˜
  async getHotProducts() {
    const cacheKey = "hot_products";
    const cached = await this.redis.get(cacheKey);

    if (cached) {
      return JSON.parse(cached);
    }

    // å¦‚æžœç¼“å­˜ä¸å­˜åœ¨ï¼Œä»Žæ•°æ®åº“æŸ¥è¯¢
    const hotProducts = await Product.find({
      availabilityStatus: "available",
    })
      .sort({ viewCount: -1, favoriteCount: -1 })
      .limit(20)
      .populate("sellerId", "firstName lastName avatarUrl")
      .lean();

    await this.redis.setex(cacheKey, 1800, JSON.stringify(hotProducts)); // 30åˆ†é’Ÿ
    return hotProducts;
  }
}
```

---

## ðŸ§ª æµ‹è¯•ç­–ç•¥

### å•å…ƒæµ‹è¯•ç¤ºä¾‹

```javascript
// tests/unit/rideshare.service.test.js
describe("RideMatchingService", () => {
  let matchingService;
  let mockMapsService;

  beforeEach(() => {
    mockMapsService = {
      calculateRoute: jest.fn(),
    };
    matchingService = new RideMatchingService();
    matchingService.mapsService = mockMapsService;
  });

  describe("findMatchingRides", () => {
    it("should find matching rides within radius", async () => {
      const searchCriteria = {
        departureLocation: { latitude: 39.9042, longitude: 116.4074 },
        destinationLocation: { latitude: 39.9388, longitude: 116.3974 },
        departureTime: new Date("2024-07-01T08:00:00Z"),
        seatsNeeded: 1,
      };

      const mockRides = [
        {
          id: 1,
          departure_location: { latitude: 39.905, longitude: 116.408 },
          destination_location: { latitude: 39.938, longitude: 116.398 },
          departure_time: new Date("2024-07-01T08:15:00Z"),
          seats_available: 3,
          seats_taken: 1,
          price_per_seat: 15,
        },
      ];

      // Mock database query
      jest
        .spyOn(matchingService, "findRidesInRadius")
        .mockResolvedValue(mockRides);

      mockMapsService.calculateRoute.mockResolvedValue({
        distance: 5000,
        duration: 1800,
        waypoints: [],
      });

      const results = await matchingService.findMatchingRides(searchCriteria);

      expect(results).toHaveLength(1);
      expect(results[0].matchingScore).toBeGreaterThan(0);
    });

    it("should filter rides by time tolerance", async () => {
      const searchCriteria = {
        departureLocation: { latitude: 39.9042, longitude: 116.4074 },
        destinationLocation: { latitude: 39.9388, longitude: 116.3974 },
        departureTime: new Date("2024-07-01T08:00:00Z"),
        seatsNeeded: 1,
      };

      const mockRides = [
        {
          id: 1,
          departure_time: new Date("2024-07-01T08:15:00Z"), // 15åˆ†é’Ÿå·®è·ï¼Œåº”è¯¥åŒ¹é…
          seats_available: 3,
          seats_taken: 1,
        },
        {
          id: 2,
          departure_time: new Date("2024-07-01T10:30:00Z"), // 2.5å°æ—¶å·®è·ï¼Œä¸åº”è¯¥åŒ¹é…
          seats_available: 2,
          seats_taken: 0,
        },
      ];

      jest
        .spyOn(matchingService, "findRidesInRadius")
        .mockResolvedValue(mockRides);

      const timeFiltered = matchingService.filterByTime(
        mockRides,
        searchCriteria.departureTime
      );

      expect(timeFiltered).toHaveLength(1);
      expect(timeFiltered[0].id).toBe(1);
    });
  });
});

// tests/unit/notification.service.test.js
describe("NotificationService", () => {
  let notificationService;
  let mockChannels;

  beforeEach(() => {
    mockChannels = {
      push: { send: jest.fn() },
      email: { send: jest.fn() },
      inApp: { send: jest.fn() },
    };

    notificationService = new NotificationService();
    notificationService.channels = mockChannels;
  });

  describe("sendNotification", () => {
    it("should send notification through specified channels", async () => {
      const notification = {
        userId: "user123",
        type: "ride_request",
        title: "New Ride Request",
        content: "Someone wants to join your ride",
        deliveryMethods: ["push", "inApp"],
      };

      mockChannels.push.send.mockResolvedValue({ success: true });
      mockChannels.inApp.send.mockResolvedValue({ success: true });

      // Mock user preferences
      jest
        .spyOn(notificationService, "getUserNotificationPreferences")
        .mockResolvedValue({
          push: true,
          email: false,
          inApp: true,
        });

      await notificationService.sendNotification(notification);

      expect(mockChannels.push.send).toHaveBeenCalled();
      expect(mockChannels.inApp.send).toHaveBeenCalled();
      expect(mockChannels.email.send).not.toHaveBeenCalled();
    });
  });
});
```

### é›†æˆæµ‹è¯•

```javascript
// tests/integration/marketplace.test.js
describe("Marketplace API Integration", () => {
  let server;
  let authToken;
  let testUser;
  let testProduct;

  beforeAll(async () => {
    server = require("../../src/app");
    testUser = await createTestUser();
    authToken = await loginTestUser(testUser.email, "password");
  });

  afterAll(async () => {
    await cleanupTestData();
    server.close();
  });

  describe("POST /api/marketplace/products", () => {
    it("should create a new product listing", async () => {
      const productData = {
        title: "Test Product",
        description: "This is a test product for sale",
        category: "electronics",
        condition: "like_new",
        price: 299.99,
        brand: "Test Brand",
        negotiable: true,
      };

      const response = await request(server)
        .post("/api/marketplace/products")
        .set("Authorization", `Bearer ${authToken}`)
        .send(productData)
        .expect(201);

      expect(response.body.success).toBe(true);
      expect(response.body.data.product.title).toBe(productData.title);
      testProduct = response.body.data.product;
    });
  });

  describe("POST /api/marketplace/products/:id/purchase", () => {
    it("should initiate product purchase", async () => {
      const buyerUser = await createTestUser({ email: "buyer@test.com" });
      const buyerToken = await loginTestUser("buyer@test.com", "password");

      const purchaseData = {
        paymentMethod: "alipay",
        deliveryOption: "pickup",
        message: "I would like to buy this item",
      };

      const response = await request(server)
        .post(`/api/marketplace/products/${testProduct.id}/purchase`)
        .set("Authorization", `Bearer ${buyerToken}`)
        .send(purchaseData)
        .expect(200);

      expect(response.body.success).toBe(true);
      expect(response.body.data.transactionId).toBeDefined();
      expect(response.body.data.status).toBe("processing");
    });

    it("should prevent self-purchase", async () => {
      const purchaseData = {
        paymentMethod: "cash",
        deliveryOption: "pickup",
      };

      const response = await request(server)
        .post(`/api/marketplace/products/${testProduct.id}/purchase`)
        .set("Authorization", `Bearer ${authToken}`)
        .send(purchaseData)
        .expect(400);

      expect(response.body.success).toBe(false);
      expect(response.body.message).toContain("cannot purchase your own");
    });
  });
});
```

---

## ðŸš€ éƒ¨ç½²ä¸Žè¿ç»´

### Docker é…ç½®

```dockerfile
# Multi-stage build for production
FROM node:18-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production && npm cache clean --force

FROM node:18-alpine AS production

# Install system dependencies
RUN apk add --no-cache \
    imagemagick \
    graphicsmagick \
    && rm -rf /var/cache/apk/*

WORKDIR /app

# Create app user
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodeuser -u 1001

# Copy node_modules from builder stage
COPY --from=builder --chown=nodeuser:nodejs /app/node_modules ./node_modules

# Copy application code
COPY --chown=nodeuser:nodejs . .

# Create uploads directory
RUN mkdir -p uploads && chown nodeuser:nodejs uploads

USER nodeuser

EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
  CMD node healthcheck.js

CMD ["npm", "start"]
```

### Kubernetes é…ç½®

```yaml
# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: campusride-backend-module2
  labels:
    app: campusride-backend-module2
spec:
  replicas: 3
  selector:
    matchLabels:
      app: campusride-backend-module2
  template:
    metadata:
      labels:
        app: campusride-backend-module2
    spec:
      containers:
        - name: app
          image: campusride/backend-module2:latest
          ports:
            - containerPort: 3000
          env:
            - name: NODE_ENV
              value: "production"
            - name: DATABASE_URL
              valueFrom:
                secretKeyRef:
                  name: database-secret
                  key: url
            - name: REDIS_URL
              valueFrom:
                secretKeyRef:
                  name: redis-secret
                  key: url
          resources:
            requests:
              memory: "256Mi"
              cpu: "250m"
            limits:
              memory: "512Mi"
              cpu: "500m"
          livenessProbe:
            httpGet:
              path: /health
              port: 3000
            initialDelaySeconds: 30
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /ready
              port: 3000
            initialDelaySeconds: 5
            periodSeconds: 5
          volumeMounts:
            - name: upload-storage
              mountPath: /app/uploads
      volumes:
        - name: upload-storage
          persistentVolumeClaim:
            claimName: upload-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: campusride-backend-module2-service
spec:
  selector:
    app: campusride-backend-module2
  ports:
    - protocol: TCP
      port: 80
      targetPort: 3000
  type: ClusterIP
```

### ç›‘æŽ§é…ç½®

```javascript
// monitoring/metrics.js
const prometheus = require("prom-client");

// åˆ›å»ºæŒ‡æ ‡
const httpRequestDurations = new prometheus.Histogram({
  name: "http_request_duration_seconds",
  help: "Duration of HTTP requests in seconds",
  labelNames: ["method", "route", "status_code"],
  buckets: [0.1, 0.3, 0.5, 0.7, 1, 3, 5, 7, 10],
});

const activeRides = new prometheus.Gauge({
  name: "active_rides_total",
  help: "Total number of active rides",
});

const productSearchRequests = new prometheus.Counter({
  name: "product_search_requests_total",
  help: "Total number of product search requests",
  labelNames: ["category"],
});

const notificationsSent = new prometheus.Counter({
  name: "notifications_sent_total",
  help: "Total number of notifications sent",
  labelNames: ["type", "channel", "status"],
});

// ä¸­é—´ä»¶
const metricsMiddleware = (req, res, next) => {
  const start = Date.now();

  res.on("finish", () => {
    const duration = (Date.now() - start) / 1000;
    httpRequestDurations
      .labels(req.method, req.route?.path || req.url, res.statusCode)
      .observe(duration);
  });

  next();
};

// ä¸šåŠ¡æŒ‡æ ‡æ”¶é›†
const updateActiveRidesCount = async () => {
  const count = await Ride.countDocuments({
    status: { $in: ["confirmed", "ongoing"] },
  });
  activeRides.set(count);
};

// å®šæœŸæ›´æ–°æŒ‡æ ‡
setInterval(updateActiveRidesCount, 30000); // æ¯30ç§’æ›´æ–°ä¸€æ¬¡

module.exports = {
  httpRequestDurations,
  activeRides,
  productSearchRequests,
  notificationsSent,
  metricsMiddleware,
};
```

---

## ðŸ”’ å®‰å…¨è€ƒè™‘

### å®‰å…¨ä¸­é—´ä»¶

```javascript
// security/middleware.js
const rateLimit = require("express-rate-limit");
const helmet = require("helmet");
const validator = require("validator");

// é€ŸçŽ‡é™åˆ¶
const createRateLimiter = (windowMs, max, message) => {
  return rateLimit({
    windowMs,
    max,
    message: { success: false, message },
    standardHeaders: true,
    legacyHeaders: false,
    store: new RedisStore({
      client: redisClient,
      prefix: "rl:",
    }),
  });
};

// APIé€ŸçŽ‡é™åˆ¶
const apiLimiter = createRateLimiter(
  15 * 60 * 1000, // 15åˆ†é’Ÿ
  100, // 100ä¸ªè¯·æ±‚
  "Too many requests from this IP, please try again later"
);

// æœç´¢APIé™åˆ¶
const searchLimiter = createRateLimiter(
  60 * 1000, // 1åˆ†é’Ÿ
  20, // 20ä¸ªæœç´¢è¯·æ±‚
  "Search rate limit exceeded"
);

// æ–‡ä»¶ä¸Šä¼ é™åˆ¶
const uploadLimiter = createRateLimiter(
  60 * 60 * 1000, // 1å°æ—¶
  50, // 50ä¸ªæ–‡ä»¶
  "Upload rate limit exceeded"
);

// è¾“å…¥æ¸…ç†ä¸­é—´ä»¶
const sanitizeInput = (req, res, next) => {
  const sanitizeValue = (value) => {
    if (typeof value === "string") {
      return validator.escape(value.trim());
    }
    if (Array.isArray(value)) {
      return value.map(sanitizeValue);
    }
    if (value && typeof value === "object") {
      const sanitized = {};
      for (const [key, val] of Object.entries(value)) {
        sanitized[key] = sanitizeValue(val);
      }
      return sanitized;
    }
    return value;
  };

  // æ¸…ç†è¯·æ±‚ä½“
  if (req.body) {
    req.body = sanitizeValue(req.body);
  }

  // æ¸…ç†æŸ¥è¯¢å‚æ•°
  if (req.query) {
    req.query = sanitizeValue(req.query);
  }

  next();
};

// SQLæ³¨å…¥é˜²æŠ¤
const preventSQLInjection = (req, res, next) => {
  const checkForSQLInjection = (str) => {
    const sqlPatterns = [
      /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION)\b)/gi,
      /(;|\||&|'|"|<|>)/g,
      /(--)|(\/\*)|(\*\/)/g,
    ];

    return sqlPatterns.some((pattern) => pattern.test(str));
  };

  const checkObject = (obj) => {
    for (const [key, value] of Object.entries(obj)) {
      if (typeof value === "string" && checkForSQLInjection(value)) {
        return true;
      }
      if (typeof value === "object" && value !== null) {
        if (checkObject(value)) return true;
      }
    }
    return false;
  };

  if (req.body && checkObject(req.body)) {
    return res.status(400).json({
      success: false,
      message: "Invalid input detected",
    });
  }

  if (req.query && checkObject(req.query)) {
    return res.status(400).json({
      success: false,
      message: "Invalid query parameters",
    });
  }

  next();
};

// å®‰å…¨å¤´éƒ¨é…ç½®
const securityHeaders = helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'", "wss:", "https:"],
      fontSrc: ["'self'"],
      objectSrc: ["'none'"],
      mediaSrc: ["'self'"],
      frameSrc: ["'none'"],
    },
  },
  crossOriginEmbedderPolicy: false,
});

module.exports = {
  apiLimiter,
  searchLimiter,
  uploadLimiter,
  sanitizeInput,
  preventSQLInjection,
  securityHeaders,
};
```

---

## ðŸ“‹ å¼€å‘æ£€æŸ¥æ¸…å•

### å¼€å‘å‰å‡†å¤‡

- [ ] çŽ¯å¢ƒå˜é‡é…ç½®å®Œæˆ
- [ ] æ•°æ®åº“è¿žæŽ¥æµ‹è¯•é€šè¿‡
- [ ] Redis è¿žæŽ¥æµ‹è¯•é€šè¿‡
- [ ] ç¬¬ä¸‰æ–¹æœåŠ¡ API å¯†é’¥é…ç½®
- [ ] WebSocket æœåŠ¡å™¨é…ç½®
- [ ] æ–‡ä»¶å­˜å‚¨æœåŠ¡é…ç½®

### åŠŸèƒ½å¼€å‘æ£€æŸ¥

- [ ] æ‰€æœ‰ API æŽ¥å£å®žçŽ°è®¤è¯é‰´æƒ
- [ ] è¾“å…¥éªŒè¯å’Œæ¸…ç†ä¸­é—´ä»¶
- [ ] é”™è¯¯å¤„ç†å’Œæ—¥å¿—è®°å½•
- [ ] å®žæ—¶é€šçŸ¥åŠŸèƒ½æµ‹è¯•
- [ ] æ–‡ä»¶ä¸Šä¼ å®‰å…¨æ£€æŸ¥
- [ ] åœ°ç†ä½ç½®æœåŠ¡é›†æˆ

### æ€§èƒ½ä¼˜åŒ–æ£€æŸ¥

- [ ] æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–
- [ ] ç¼“å­˜ç­–ç•¥å®žçŽ°
- [ ] æŽ¥å£å“åº”æ—¶é—´ç›‘æŽ§
- [ ] å¹¶å‘å¤„ç†èƒ½åŠ›æµ‹è¯•
- [ ] å†…å­˜ä½¿ç”¨ç›‘æŽ§

### å®‰å…¨æ£€æŸ¥

- [ ] SQL æ³¨å…¥é˜²æŠ¤
- [ ] XSS æ”»å‡»é˜²æŠ¤
- [ ] æ–‡ä»¶ä¸Šä¼ å®‰å…¨éªŒè¯
- [ ] æ•æ„Ÿä¿¡æ¯åŠ å¯†å­˜å‚¨
- [ ] API é€ŸçŽ‡é™åˆ¶

### æµ‹è¯•è¦†ç›–

- [ ] å•å…ƒæµ‹è¯•è¦†ç›–çŽ‡ > 80%
- [ ] é›†æˆæµ‹è¯•å®Œæˆ
- [ ] WebSocket è¿žæŽ¥æµ‹è¯•
- [ ] æ–‡ä»¶ä¸Šä¼ åŠŸèƒ½æµ‹è¯•
- [ ] æ”¯ä»˜æµç¨‹æµ‹è¯•

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åŽæ›´æ–°**: 2024-06-30  
**è´Ÿè´£äºº**: Cursor AI  
**å®¡æ ¸äºº**: å¾…å®š

---

_æœ¬æ–‡æ¡£åŒ…å«æ¨¡å— 2 çš„å®Œæ•´å¼€å‘è§„èŒƒï¼Œè¯·ä¸¥æ ¼æŒ‰ç…§æ–‡æ¡£è¿›è¡Œå¼€å‘ï¼Œç¡®ä¿ä¸Žæ¨¡å— 1 çš„è‰¯å¥½é›†æˆã€‚_
